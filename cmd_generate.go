package ddtrace

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/Masterminds/sprig/v3"
	"github.com/pkg/errors"

	"github.com/tyson-tuanvm/ddtrace/generator"
	"github.com/tyson-tuanvm/ddtrace/pkg"
)

// GenerateCommand implements Command interface
type GenerateCommand struct {
	BaseCommand

	interfaceNamesStr string   // Keep as string for flag parsing
	interfaceNames    []string // Parse from interfaceNamesStr
	outputFile        string
	sourcePkg         string
	noGenerate        bool
	vars              vars
	localPrefix       string

	filepath fs
}

// NewGenerateCommand creates GenerateCommand
func NewGenerateCommand() *GenerateCommand {
	gc := &GenerateCommand{
		filepath: fs{
			Rel:       filepath.Rel,
			Abs:       filepath.Abs,
			Dir:       filepath.Dir,
			WriteFile: os.WriteFile,
		},
	}

	//this flagset loads flags values to the command fields
	fs := &flag.FlagSet{}
	fs.BoolVar(&gc.noGenerate, "g", false, "don't put //go:generate instruction to the generated code")
	fs.StringVar(&gc.interfaceNamesStr, "i", "", `the source interface names (comma-separated), i.e. "Reader,Writer" or "Reader"`)
	fs.StringVar(&gc.sourcePkg, "p", "", "the source package import path, i.e. \"io\", \"github.com/tyson-tuanvm/ddtrace\" or\na relative import path like \"./generator\"")
	fs.StringVar(&gc.outputFile, "o", "", "the output file name")
	fs.Var(&gc.vars, "v", "a key-value pair to parametrize the template,\narguments without an equal sign are treated as a bool values,\ni.e. -v foo=bar -v disableChecks")
	fs.StringVar(&gc.localPrefix, "l", "", "put imports beginning with this string after 3rd-party packages; comma-separated list")

	gc.BaseCommand = BaseCommand{
		Short: "generate decorators",
		Usage: "-p package -i interfaceNames output_file.go",
		Flags: fs,
	}

	return gc
}

// Run implements Command interface
func (gc *GenerateCommand) Run(args []string, stdout io.Writer) error {
	if err := gc.FlagSet().Parse(args); err != nil {
		return CommandLineError(err.Error())
	}

	// Parse comma-separated interface names after flag parsing
	gc.parseInterfaceNames()

	if err := gc.checkFlags(); err != nil {
		return err
	}

	if err := os.MkdirAll(filepath.Dir(gc.outputFile), os.ModePerm); err != nil {
		return err
	}

	// For a single interface, use the original approach
	if len(gc.interfaceNames) == 1 {
		generatorOptions, err := gc.getOptionsForInterface(gc.interfaceNames[0])
		if err != nil {
			return err
		}

		gen, err := generator.NewGenerator(*generatorOptions)
		if err != nil {
			return err
		}

		buf := bytes.NewBuffer([]byte{})
		if err := gen.Generate(buf); err != nil {
			return err
		}

		return gc.filepath.WriteFile(gc.outputFile, buf.Bytes(), 0664)
	}

	// For multiple interfaces, generate each one separately and combine
	var allOutput bytes.Buffer

	// Write header once
	if err := gc.writeMultiInterfaceHeader(&allOutput); err != nil {
		return err
	}

	// Generate wrapper for each interface
	for i, interfaceName := range gc.interfaceNames {
		if i > 0 {
			allOutput.WriteString("\n") // Add separator between interfaces
		}

		if err := gc.generateInterfaceBody(&allOutput, interfaceName); err != nil {
			return err
		}
	}

	return gc.filepath.WriteFile(gc.outputFile, allOutput.Bytes(), 0664)
}

func (gc *GenerateCommand) parseInterfaceNames() {
	if gc.interfaceNamesStr != "" {
		names := strings.Split(gc.interfaceNamesStr, ",")
		gc.interfaceNames = make([]string, 0, len(names))
		for _, name := range names {
			trimmed := strings.TrimSpace(name)
			if trimmed != "" {
				gc.interfaceNames = append(gc.interfaceNames, trimmed)
			}
		}
	} else {
		// Ensure we return an empty slice instead of nil for empty input
		gc.interfaceNames = []string{}
	}
}

func (gc *GenerateCommand) writeMultiInterfaceHeader(buf io.Writer) error {
	// Create a basic template for the header when handling multiple interfaces
	headerTmpl := `// Code generated by ddtrace. DO NOT EDIT.
// template: {{.Template}}
// ddtrace: http://github.com/tyson-tuanvm/ddtrace

package {{.PackageName}}

{{if (not .DisableGoGenerate)}}
//go:generate ddtrace gen -p {{.SourcePackage}} -i {{.InterfaceNames}} -o {{.OutputFileName}}{{.VarsArgs}} -l "{{.LocalPrefix}}"
{{end}}

import (
    "context"

    "gopkg.in/DataDog/dd-trace-go.v1/ddtrace"
    "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/ext"
    "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

`

	tmpl, err := template.New("header").Parse(headerTmpl)
	if err != nil {
		return err
	}

	if gc.sourcePkg == "" {
		gc.sourcePkg = "./"
	}

	sourcePackage, err := pkg.Load(gc.sourcePkg)
	if err != nil {
		return errors.Wrap(err, "failed to load source package")
	}

	// Get destination package name
	dstPackagePath := filepath.Dir(gc.outputFile)
	if !strings.HasPrefix(dstPackagePath, "/") && !strings.HasPrefix(dstPackagePath, "./") {
		dstPackagePath = "./" + dstPackagePath
	}

	var packageName string
	if dstPackagePath == "./" || dstPackagePath == "." {
		// If output is in current directory, try to get package name from go.mod or use "main"
		if currentPkg, err := pkg.Load("./"); err == nil {
			packageName = currentPkg.Name
		} else {
			packageName = "main"
		}
	} else {
		dstPackage, err := pkg.Load(dstPackagePath)
		if err != nil {
			// Use directory name as package name
			packageName = filepath.Base(dstPackagePath)
		} else {
			packageName = dstPackage.Name
		}
	}

	templateData := map[string]interface{}{
		"Template":          "datadog",
		"PackageName":       packageName,
		"DisableGoGenerate": gc.noGenerate,
		"SourcePackage":     sourcePackage.PkgPath,
		"InterfaceNames":    strings.Join(gc.interfaceNames, ","),
		"OutputFileName":    filepath.Base(gc.outputFile),
		"VarsArgs":          varsToArgs(gc.vars),
		"LocalPrefix":       gc.localPrefix,
	}

	// Execute template to a temporary buffer first to see what's generated
	tempHeaderBuf := bytes.NewBuffer([]byte{})
	err = tmpl.Execute(tempHeaderBuf, templateData)
	if err != nil {
		return err
	}

	// Write to the actual buffer
	_, err = buf.Write(tempHeaderBuf.Bytes())
	return err
}

func (gc *GenerateCommand) generateInterfaceBody(buf io.Writer, interfaceName string) error {
	// Create generator with normal options to generate a complete file
	generatorOptions, err := gc.getOptionsForInterface(interfaceName)
	if err != nil {
		return err
	}

	gen, err := generator.NewGenerator(*generatorOptions)
	if err != nil {
		return err
	}

	// Generate complete output
	tempBuffer := bytes.NewBuffer([]byte{})
	if err := gen.Generate(tempBuffer); err != nil {
		return err
	}

	// Extract only the struct and method definitions
	content := tempBuffer.String()

	// Find the actual interface wrapper code (structs, constructors, methods)
	lines := strings.Split(content, "\n")
	var bodyLines []string
	inImportBlock := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip everything until we find the actual code
		if strings.HasPrefix(trimmed, "package ") ||
			strings.HasPrefix(trimmed, "//") ||
			trimmed == "" {
			continue
		}

		// Handle import block
		if strings.HasPrefix(trimmed, "import") {
			inImportBlock = true
			continue
		}
		if inImportBlock {
			if trimmed == ")" {
				inImportBlock = false
			}
			continue
		}

		// Once we're past imports and comments, include everything
		if !inImportBlock && trimmed != "" {
			bodyLines = append(bodyLines, line)
		}
	}

	// Write the extracted body
	for _, line := range bodyLines {
		buf.Write([]byte(line + "\n"))
	}

	return nil
}

func (gc *GenerateCommand) getOptionsForInterface(interfaceName string) (*generator.Options, error) {
	options := generator.Options{
		InterfaceName:  interfaceName,
		OutputFile:     gc.outputFile,
		Funcs:          helperFuncs,
		HeaderTemplate: headerTemplate,
		HeaderVars: map[string]interface{}{
			"DisableGoGenerate": gc.noGenerate,
			"OutputFileName":    filepath.Base(gc.outputFile),
			"VarsArgs":          varsToArgs(gc.vars),
		},
		Vars:        gc.vars.toMap(),
		LocalPrefix: gc.localPrefix,
	}

	if gc.sourcePkg == "" {
		gc.sourcePkg = "./"
	}

	sourcePackage, err := pkg.Load(gc.sourcePkg)
	if err != nil {
		return nil, errors.Wrap(err, "failed to load source package")
	}

	options.SourcePackage = sourcePackage.PkgPath
	options.SourcePackageInstance = sourcePackage // Pass the loaded package
	options.BodyTemplate, options.HeaderVars["Template"], err = gc.loadTemplate("")

	return &options, err
}

var (
	errNoOutputFile     = CommandLineError("output file is not specified")
	errNoInterfaceNames = CommandLineError("interface names are not specified")
)

func (gc *GenerateCommand) checkFlags() error {
	if gc.outputFile == "" {
		return errNoOutputFile
	}

	if len(gc.interfaceNames) == 0 {
		return errNoInterfaceNames
	}

	return nil
}

func (gc *GenerateCommand) loadTemplate(outputFileDir string) (contents, url string, err error) {
	return datadogTemplate, "datadog", nil
}

type fs struct {
	Rel       func(string, string) (string, error)
	Abs       func(string) (string, error)
	Dir       func(string) string
	WriteFile func(string, []byte, os.FileMode) error
}

type varFlag struct {
	name  string
	value interface{}
}

// vars is a helper type that implements flag.Value to read multiple vars from the command line
type vars []varFlag

// String implements flag.Value
func (v vars) String() string {
	return fmt.Sprintf("%#v", v)
}

func (v *vars) Set(s string) error {
	chunks := strings.SplitN(s, "=", 2)
	switch len(chunks) {
	case 1:
		*v = append(*v, varFlag{name: chunks[0], value: true})
	case 2:
		*v = append(*v, varFlag{name: chunks[0], value: chunks[1]})
	}

	return nil
}

func (v vars) toMap() map[string]interface{} {
	m := make(map[string]interface{}, len(v))
	for _, vf := range v {
		m[vf.name] = vf.value
	}

	return m
}

func varsToArgs(v vars) string {
	if len(v) == 0 {
		return ""
	}

	var ss []string

	for _, vf := range v {
		switch typedValue := vf.value.(type) {
		case string:
			ss = append(ss, vf.name+"="+typedValue)
		case bool:
			ss = append(ss, vf.name)
		}
	}

	return " -v " + strings.Join(ss, " -v ")
}

var helperFuncs template.FuncMap

func init() {
	helperFuncs = sprig.TxtFuncMap()

	helperFuncs["up"] = strings.ToUpper
	helperFuncs["down"] = strings.ToLower
	helperFuncs["upFirst"] = upFirst
	helperFuncs["downFirst"] = downFirst
	helperFuncs["replace"] = strings.ReplaceAll
	helperFuncs["snake"] = toSnakeCase
}

func upFirst(s string) string {
	for _, v := range s {
		return string(unicode.ToUpper(v)) + s[len(string(v)):]
	}
	return ""
}

func downFirst(s string) string {
	for _, v := range s {
		return string(unicode.ToLower(v)) + s[len(string(v)):]
	}
	return ""
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(str string) string {
	result := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	result = matchAllCap.ReplaceAllString(result, "${1}_${2}")
	return strings.ToLower(result)
}

const datadogTemplate = `import (
    "context"

    "gopkg.in/DataDog/dd-trace-go.v1/ddtrace"
    "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/ext"
    "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

{{ $decorator := (or .Vars.DecoratorName (printf "%sWithTracing" .Interface.Name)) }}
{{ $spanNameType := (or .Vars.SpanNamePrefix .Interface.Name) }}

// {{$decorator}} implements {{.Interface.Name}} interface instrumented with Datadog tracing
type {{$decorator}} struct {
  {{.Interface.Type}}
  _spanDecorator func(span ddtrace.Span, params, results map[string]interface{})
}

// New{{$decorator}} returns {{$decorator}}
func New{{$decorator}} (base {{.Interface.Type}}, instance string, spanDecorator ...func(span ddtrace.Span, params, results map[string]interface{})) {{$decorator}} {
  d := {{$decorator}} {
    {{.Interface.Name}}: base,
  }

  if len(spanDecorator) > 0 && spanDecorator[0] != nil {
    d._spanDecorator = spanDecorator[0]
  }

  return d
}

{{range $method := .Interface.Methods}}
  {{if $method.AcceptsContext}}
    // {{$method.Name}} implements {{$.Interface.Name}}
func (_d {{$decorator}}) {{$method.Declaration}} {
  span, ctx := tracer.StartSpanFromContext(ctx, "{{$spanNameType}}.{{$method.Name}}")
  defer func() {
    if _d._spanDecorator != nil {
      _d._spanDecorator(span, {{$method.ParamsMap}}, {{$method.ResultsMap}})
    }{{- if $method.ReturnsError}} else if err != nil {
      span.SetTag(ext.Error, err)
      span.SetTag(ext.ErrorMsg, err.Error())
      span.SetTag(ext.ErrorType, "error")
    }
    {{end}}
    span.Finish()
  }()
  {{$method.Pass (printf "_d.%s." $.Interface.Name) }}
}
  {{end}}
{{end}}
`

const headerTemplate = `// Code generated by ddtrace. DO NOT EDIT.
// template: {{.Options.HeaderVars.Template}}
// ddtrace: http://github.com/tyson-tuanvm/ddtrace

package {{.Package.Name}}

{{if (not .Options.HeaderVars.DisableGoGenerate)}}
//{{"go:generate"}} ddtrace gen -p {{.SourcePackage.PkgPath}} -i {{.Options.InterfaceName}} -o {{.Options.HeaderVars.OutputFileName}}{{.Options.HeaderVars.VarsArgs}} -l "{{.Options.LocalPrefix}}"
{{end}}
import(
{{range $import := .Options.Imports}}{{$import}}
	{{end}}
)
`
