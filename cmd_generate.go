package ddtrace

import (
	"bytes"
	"flag"
	"fmt"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"unicode"

	"github.com/Masterminds/sprig/v3"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"

	"github.com/tuanvm-tyson/ddtrace/generator"
	"github.com/tuanvm-tyson/ddtrace/pkg"
)

// GenerateCommand implements Command interface
type GenerateCommand struct {
	BaseCommand

	sourcePkg  string
	outputDir  string
	noGenerate bool

	filepath fileSystem
}

type fileSystem struct {
	WriteFile func(string, []byte, os.FileMode) error
	MkdirAll  func(string, os.FileMode) error
}

// NewGenerateCommand creates GenerateCommand
func NewGenerateCommand() *GenerateCommand {
	gc := &GenerateCommand{
		filepath: fileSystem{
			WriteFile: os.WriteFile,
			MkdirAll:  os.MkdirAll,
		},
	}

	fs := &flag.FlagSet{}
	fs.StringVar(&gc.sourcePkg, "p", "", `source package path (default: "./")`)
	fs.StringVar(&gc.outputDir, "o", "", `output directory for generated files (default: "./trace")`)
	fs.BoolVar(&gc.noGenerate, "g", false, "don't put //go:generate instruction to the generated code")

	gc.BaseCommand = BaseCommand{
		Short: "generate tracing decorators for all interfaces in a package",
		Usage: "[-p package] [-o output_dir] [-g]",
		Flags: fs,
	}

	return gc
}

// Run implements Command interface
func (gc *GenerateCommand) Run(args []string, stdout io.Writer) error {
	if err := gc.FlagSet().Parse(args); err != nil {
		return CommandLineError(err.Error())
	}

	// Apply defaults
	if gc.sourcePkg == "" {
		gc.sourcePkg = "./"
	}
	if gc.outputDir == "" {
		gc.outputDir = "./trace"
	}

	// Load source package
	sourcePackage, err := pkg.Load(gc.sourcePkg)
	if err != nil {
		return errors.Wrap(err, "failed to load source package")
	}

	// Parse AST
	fset := token.NewFileSet()
	astPkg, err := pkg.AST(fset, sourcePackage)
	if err != nil {
		return errors.Wrap(err, "failed to parse source package AST")
	}

	// Scan for all interfaces, filter out //ddtrace:ignore
	fileGroups, err := pkg.ScanPackage(astPkg)
	if err != nil {
		return errors.Wrap(err, "failed to scan interfaces")
	}

	if len(fileGroups) == 0 {
		return nil // No interfaces found, not an error
	}

	// Resolve output directory relative to source package directory
	srcDir := pkg.Dir(sourcePackage)
	outDir := gc.outputDir
	if !filepath.IsAbs(outDir) {
		outDir = filepath.Join(srcDir, outDir)
	}

	if err := gc.filepath.MkdirAll(outDir, os.ModePerm); err != nil {
		return errors.Wrap(err, "failed to create output directory")
	}

	// Generate one output file per source file
	wroteGoGenerate := false
	for _, fg := range fileGroups {
		outFileName := strings.TrimSuffix(fg.FileName, ".go") + "_trace.go"
		outFilePath := filepath.Join(outDir, outFileName)

		// Only write //go:generate in the first output file
		includeGoGenerate := !gc.noGenerate && !wroteGoGenerate

		if err := gc.generateFileDecorators(sourcePackage, fg, outFilePath, includeGoGenerate); err != nil {
			return errors.Wrapf(err, "failed to generate for %s", fg.FileName)
		}

		if includeGoGenerate {
			wroteGoGenerate = true
		}
	}

	return nil
}

// generateFileDecorators generates tracing decorators for all interfaces in a single source file.
func (gc *GenerateCommand) generateFileDecorators(
	sourcePackage *packages.Package,
	fg pkg.FileInterfaces,
	outFilePath string,
	includeGoGenerate bool,
) error {
	var buf bytes.Buffer

	// Determine output package name from the output directory name
	outPkgName := filepath.Base(filepath.Dir(outFilePath))

	// Write file header
	fmt.Fprintf(&buf, "// Code generated by ddtrace. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// source: %s\n", fg.FileName)
	fmt.Fprintf(&buf, "// ddtrace: http://github.com/tuanvm-tyson/ddtrace\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", outPkgName)

	if includeGoGenerate {
		fmt.Fprintf(&buf, "//go:generate ddtrace gen -p %s -o %s\n\n", sourcePackage.PkgPath, gc.outputDir)
	}

	// Generate each interface through the existing generator engine.
	// The first interface's output includes imports (with the aliased source package import).
	// Subsequent interfaces only contribute their struct/method bodies.
	generatedAny := false
	for _, iface := range fg.Interfaces {
		genOutput, err := gc.generateInterfaceOutput(sourcePackage, iface.Name, outFilePath)
		if err != nil {
			// Skip interfaces that cannot be generated (e.g., empty interfaces)
			continue
		}

		if !generatedAny {
			// First interface: include imports + body (strip only the package line)
			buf.WriteString(extractAfterPackage(genOutput))
		} else {
			// Subsequent interfaces: body only (strip package + imports)
			buf.WriteString(extractBodyOnly(genOutput))
		}
		buf.WriteString("\n")
		generatedAny = true
	}

	if !generatedAny {
		return nil // All interfaces were empty or had issues, skip this file
	}

	// Format with goimports to merge/clean imports and format code
	processed, err := imports.Process(outFilePath, buf.Bytes(), nil)
	if err != nil {
		return errors.Wrapf(err, "failed to format generated code:\n%s", buf.String())
	}

	return gc.filepath.WriteFile(outFilePath, processed, 0664)
}

// generateInterfaceOutput uses the existing generator engine to produce a complete
// formatted Go file for a single interface.
func (gc *GenerateCommand) generateInterfaceOutput(
	sourcePackage *packages.Package,
	interfaceName string,
	outFilePath string,
) (string, error) {
	options := generator.Options{
		InterfaceName:         interfaceName,
		OutputFile:            outFilePath,
		SourcePackage:         sourcePackage.PkgPath,
		SourcePackageInstance: sourcePackage,
		Funcs:                 helperFuncs,
		HeaderTemplate:        minimalHeaderTemplate,
		BodyTemplate:          datadogTemplate,
		Vars:                  make(map[string]interface{}),
		HeaderVars:            make(map[string]interface{}),
	}

	gen, err := generator.NewGenerator(options)
	if err != nil {
		return "", err
	}

	var genBuf bytes.Buffer
	if err := gen.Generate(&genBuf); err != nil {
		return "", err
	}

	return genBuf.String(), nil
}

// extractAfterPackage strips the package declaration line (and preceding comments)
// from generated Go source, keeping imports and all code.
func extractAfterPackage(content string) string {
	lines := strings.Split(content, "\n")
	foundPackage := false

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if !foundPackage && strings.HasPrefix(trimmed, "package ") {
			foundPackage = true
			// Return everything after the package line
			rest := strings.Join(lines[i+1:], "\n")
			return strings.TrimLeft(rest, "\n")
		}
	}

	return content
}

// extractBodyOnly strips the package declaration, imports, and leading comments
// from generated Go source, returning only struct and method definitions.
func extractBodyOnly(content string) string {
	lines := strings.Split(content, "\n")
	var bodyLines []string
	inImportBlock := false
	foundBody := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Handle multi-line import block
		if !foundBody && (strings.HasPrefix(trimmed, "import (") || trimmed == "import(") {
			inImportBlock = true
			continue
		}
		if !foundBody && strings.HasPrefix(trimmed, "import ") && !strings.Contains(trimmed, "(") {
			continue
		}
		if inImportBlock {
			if trimmed == ")" {
				inImportBlock = false
			}
			continue
		}

		// Skip package declaration and comments before body
		if !foundBody {
			if trimmed == "" || strings.HasPrefix(trimmed, "package ") || strings.HasPrefix(trimmed, "//") {
				continue
			}
			foundBody = true
		}

		bodyLines = append(bodyLines, line)
	}

	// Trim trailing empty lines
	for len(bodyLines) > 0 && strings.TrimSpace(bodyLines[len(bodyLines)-1]) == "" {
		bodyLines = bodyLines[:len(bodyLines)-1]
	}

	return strings.Join(bodyLines, "\n")
}

// minimalHeaderTemplate is used when generating individual interface bodies.
// It includes the package clause and source package imports so cross-package
// type references (e.g., _sourcePkg.InterfaceName) resolve correctly.
const minimalHeaderTemplate = `package {{.Package.Name}}

import(
{{range $import := .Options.Imports}}	{{$import}}
{{end}})
`

var helperFuncs template.FuncMap

func init() {
	helperFuncs = sprig.TxtFuncMap()

	helperFuncs["up"] = strings.ToUpper
	helperFuncs["down"] = strings.ToLower
	helperFuncs["upFirst"] = upFirst
	helperFuncs["downFirst"] = downFirst
	helperFuncs["replace"] = strings.ReplaceAll
	helperFuncs["snake"] = toSnakeCase
}

func upFirst(s string) string {
	for _, v := range s {
		return string(unicode.ToUpper(v)) + s[len(string(v)):]
	}
	return ""
}

func downFirst(s string) string {
	for _, v := range s {
		return string(unicode.ToLower(v)) + s[len(string(v)):]
	}
	return ""
}

var matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
var matchAllCap = regexp.MustCompile("([a-z0-9])([A-Z])")

func toSnakeCase(str string) string {
	result := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	result = matchAllCap.ReplaceAllString(result, "${1}_${2}")
	return strings.ToLower(result)
}

const datadogTemplate = `import (
    "context"

    "github.com/tuanvm-tyson/ddtrace/tracing"
)

{{ $decorator := (or .Vars.DecoratorName (printf "%sWithTracing" .Interface.Name)) }}
{{ $spanNameType := (or .Vars.SpanNamePrefix .Interface.Name) }}

// {{$decorator}} implements {{.Interface.Name}} interface instrumented with Datadog tracing
type {{$decorator}} struct {
  {{.Interface.Type}}
  _cfg tracing.TracingConfig
}

// New{{$decorator}} returns {{$decorator}}
func New{{$decorator}} (base {{.Interface.Type}}, opts ...tracing.TracingOption) {{$decorator}} {
  return {{$decorator}} {
    {{.Interface.Name}}: base,
    _cfg: tracing.NewTracingConfig(opts...),
  }
}

{{range $method := .Interface.Methods}}
  {{if $method.AcceptsContext}}
    // {{$method.Name}} implements {{$.Interface.Name}}
func (_d {{$decorator}}) {{$method.Declaration}} {
  span, ctx := _d._cfg.StartSpan(ctx, "{{$spanNameType}}.{{$method.Name}}")
  defer func() {
    _d._cfg.FinishSpan(span, {{if $method.ReturnsError}}err{{else}}nil{{end}}, {{$method.ParamsMap}}, {{$method.ResultsMap}})
  }()
  {{$method.Pass (printf "_d.%s." $.Interface.Name) }}
}
  {{end}}
{{end}}
`
