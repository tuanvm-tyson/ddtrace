package generate

import (
	"bytes"
	"fmt"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"

	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"

	"github.com/moneyforward/ddtrace/internal/codegen"
	"github.com/moneyforward/ddtrace/internal/config"
	"github.com/moneyforward/ddtrace/internal/scanner"
)

// filterInterfaces applies interface-level include/ignore rules from config.
func filterInterfaces(fileGroups []scanner.FileInterfaces, pkgCfg config.PackageConfig) []scanner.FileInterfaces {
	if len(pkgCfg.Interfaces) == 0 {
		return fileGroups
	}

	var result []scanner.FileInterfaces
	for _, fg := range fileGroups {
		var filtered []scanner.InterfaceInfo
		for _, iface := range fg.Interfaces {
			ifaceCfg, explicit := pkgCfg.Interfaces[iface.Name]
			if explicit && ifaceCfg != nil && ifaceCfg.Ignore {
				continue
			}
			filtered = append(filtered, iface)
		}
		if len(filtered) > 0 {
			result = append(result, scanner.FileInterfaces{
				FileName:   fg.FileName,
				Interfaces: filtered,
			})
		}
	}
	return result
}

// generateFileDecorators generates tracing decorators for all interfaces in a single source file.
func (gc *GenerateCommand) generateFileDecorators(
	sourcePackage *packages.Package,
	sourcePackageAST *scanner.Package,
	dstPackage *packages.Package,
	headerTmpl *template.Template,
	bodyTmpl *template.Template,
	sharedFS *token.FileSet,
	pkgCache *codegen.PackageCache,
	fg scanner.FileInterfaces,
	outFilePath string,
	includeGoGenerate bool,
	interfaceConfigs map[string]*config.InterfaceConfig,
) error {
	var buf bytes.Buffer

	outPkgName := filepath.Base(filepath.Dir(outFilePath))

	fmt.Fprintf(&buf, "// Code generated by ddtrace. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// source: %s\n", fg.FileName)
	fmt.Fprintf(&buf, "// ddtrace: http://github.com/moneyforward/ddtrace\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", outPkgName)

	if includeGoGenerate {
		fmt.Fprintf(&buf, "//go:generate ddtrace gen -p %s -o %s\n\n", sourcePackage.PkgPath, gc.outputDir)
	}

	generatedAny := false
	for _, iface := range fg.Interfaces {
		vars := make(map[string]interface{})
		if interfaceConfigs != nil {
			if ic, ok := interfaceConfigs[iface.Name]; ok && ic != nil {
				if ic.DecoratorName != "" {
					vars["DecoratorName"] = ic.DecoratorName
				}
				if ic.SpanPrefix != "" {
					vars["SpanNamePrefix"] = ic.SpanPrefix
				}
			}
		}

		genOutput, err := gc.generateInterfaceOutput(sourcePackage, sourcePackageAST, dstPackage, headerTmpl, bodyTmpl, sharedFS, pkgCache, iface.Name, outFilePath, vars)
		if err != nil {
			continue
		}

		if !generatedAny {
			buf.WriteString(extractAfterPackage(genOutput))
		} else {
			buf.WriteString(extractBodyOnly(genOutput))
		}
		buf.WriteString("\n")
		generatedAny = true
	}

	if !generatedAny {
		return nil
	}

	processed, err := imports.Process(outFilePath, buf.Bytes(), nil)
	if err != nil {
		return errors.Wrapf(err, "failed to format generated code:\n%s", buf.String())
	}

	if existing, err := os.ReadFile(outFilePath); err == nil && bytes.Equal(existing, processed) {
		now := time.Now()
		os.Chtimes(outFilePath, now, now) //nolint: errcheck
		return nil
	}

	return gc.fs.WriteFile(outFilePath, processed, 0664)
}

// generateInterfaceOutput uses the generator engine to produce a complete
// formatted Go file for a single interface.
func (gc *GenerateCommand) generateInterfaceOutput(
	sourcePackage *packages.Package,
	sourcePackageAST *scanner.Package,
	destinationPackage *packages.Package,
	headerTmpl *template.Template,
	bodyTmpl *template.Template,
	sharedFS *token.FileSet,
	pkgCache *codegen.PackageCache,
	interfaceName string,
	outFilePath string,
	vars map[string]interface{},
) (string, error) {
	if vars == nil {
		vars = make(map[string]interface{})
	}

	options := codegen.Options{
		InterfaceName:              interfaceName,
		OutputFile:                 outFilePath,
		SourcePackage:              sourcePackage.PkgPath,
		SourcePackageInstance:      sourcePackage,
		SourcePackageAST:           sourcePackageAST,
		DestinationPackageInstance: destinationPackage,
		SkipImportsProcessing:     true,
		HeaderTemplateParsed:       headerTmpl,
		BodyTemplateParsed:         bodyTmpl,
		FileSet:                    sharedFS,
		PackageCache:               pkgCache,
		Funcs:                      helperFuncs,
		Vars:                       vars,
		HeaderVars:                 make(map[string]interface{}),
	}

	gen, err := codegen.NewGenerator(options)
	if err != nil {
		return "", err
	}

	var genBuf bytes.Buffer
	if err := gen.Generate(&genBuf); err != nil {
		return "", err
	}

	return genBuf.String(), nil
}

// extractAfterPackage strips the package declaration line (and preceding comments)
// from generated Go source, keeping imports and all code.
func extractAfterPackage(content string) string {
	lines := strings.Split(content, "\n")
	foundPackage := false

	for i, line := range lines {
		trimmed := strings.TrimSpace(line)
		if !foundPackage && strings.HasPrefix(trimmed, "package ") {
			foundPackage = true
			rest := strings.Join(lines[i+1:], "\n")
			return strings.TrimLeft(rest, "\n")
		}
	}

	return content
}

// extractBodyOnly strips the package declaration, imports, and leading comments
// from generated Go source, returning only struct and method definitions.
func extractBodyOnly(content string) string {
	lines := strings.Split(content, "\n")
	var bodyLines []string
	inImportBlock := false
	foundBody := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if !foundBody && (strings.HasPrefix(trimmed, "import (") || trimmed == "import(") {
			inImportBlock = true
			continue
		}
		if !foundBody && strings.HasPrefix(trimmed, "import ") && !strings.Contains(trimmed, "(") {
			continue
		}
		if inImportBlock {
			if trimmed == ")" {
				inImportBlock = false
			}
			continue
		}

		if !foundBody {
			if trimmed == "" || strings.HasPrefix(trimmed, "package ") || strings.HasPrefix(trimmed, "//") {
				continue
			}
			foundBody = true
		}

		bodyLines = append(bodyLines, line)
	}

	for len(bodyLines) > 0 && strings.TrimSpace(bodyLines[len(bodyLines)-1]) == "" {
		bodyLines = bodyLines[:len(bodyLines)-1]
	}

	return strings.Join(bodyLines, "\n")
}
