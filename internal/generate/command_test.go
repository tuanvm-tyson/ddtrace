package generate

import (
	"io"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNewGenerateCommand(t *testing.T) {
	cmd := NewGenerateCommand()
	assert.NotNil(t, cmd)
	assert.Equal(t, "", cmd.sourcePkg)
	assert.Equal(t, "", cmd.outputDir)
	assert.False(t, cmd.noGenerate)
}

func TestGenerateCommand_Run_ParseArgsError(t *testing.T) {
	cmd := NewGenerateCommand()
	cmd.BaseCommand.FlagSet().SetOutput(io.Discard)

	err := cmd.Run([]string{"-zz"}, nil)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "flag provided but not defined")
}

func TestGenerateCommand_Run_DefaultFlags(t *testing.T) {
	var writtenFiles []string
	var writtenContents []string

	cmd := NewGenerateCommand()
	cmd.fs.WriteFile = func(name string, data []byte, perm os.FileMode) error {
		writtenFiles = append(writtenFiles, filepath.Base(name))
		writtenContents = append(writtenContents, string(data))
		return nil
	}
	cmd.fs.MkdirAll = func(path string, perm os.FileMode) error {
		return nil
	}

	// Point at the internal/cli package which has the Command interface
	err := cmd.Run([]string{"-p", "github.com/moneyforward/ddtrace/internal/cli"}, nil)
	require.NoError(t, err)

	require.Len(t, writtenFiles, 1)
	assert.Equal(t, "command_trace.go", writtenFiles[0])

	content := writtenContents[0]
	assert.Contains(t, content, "// Code generated by ddtrace. DO NOT EDIT.")
	assert.Contains(t, content, "package trace")
	assert.Contains(t, content, `"github.com/moneyforward/ddtrace/tracing"`)
	assert.Contains(t, content, "CommandWithTracing")
	assert.Contains(t, content, "NewCommandWithTracing")
	assert.Contains(t, content, "tracing.TracingConfig")
	assert.Contains(t, content, "tracing.TracingOption")
	assert.Contains(t, content, "tracing.NewTracingConfig")
	assert.NotContains(t, content, "func SetDefaultContextDecorator")
	assert.NotContains(t, content, "func StartSpan(")
	assert.NotContains(t, content, "instance string")
}

func TestGenerateCommand_Run_CustomOutputDir(t *testing.T) {
	var writtenFiles []string

	cmd := NewGenerateCommand()
	cmd.fs.WriteFile = func(name string, data []byte, perm os.FileMode) error {
		writtenFiles = append(writtenFiles, name)
		return nil
	}
	cmd.fs.MkdirAll = func(path string, perm os.FileMode) error {
		return nil
	}

	err := cmd.Run([]string{"-p", "github.com/moneyforward/ddtrace/internal/cli", "-o", "./custom_out"}, nil)
	require.NoError(t, err)

	require.Len(t, writtenFiles, 1)
	assert.Contains(t, writtenFiles[0], "custom_out")
	assert.True(t, strings.HasSuffix(writtenFiles[0], "command_trace.go"))
}

func TestGenerateCommand_Run_NoGenerateFlag(t *testing.T) {
	var writtenContents []string

	cmd := NewGenerateCommand()
	cmd.fs.WriteFile = func(name string, data []byte, perm os.FileMode) error {
		writtenContents = append(writtenContents, string(data))
		return nil
	}
	cmd.fs.MkdirAll = func(path string, perm os.FileMode) error {
		return nil
	}

	err := cmd.Run([]string{"-p", "github.com/moneyforward/ddtrace/internal/cli", "-g"}, nil)
	require.NoError(t, err)

	require.Len(t, writtenContents, 1)
	assert.NotContains(t, writtenContents[0], "go:generate")
}

func TestGenerateCommand_Run_WithGoGenerate(t *testing.T) {
	var writtenContents []string

	cmd := NewGenerateCommand()
	cmd.fs.WriteFile = func(name string, data []byte, perm os.FileMode) error {
		writtenContents = append(writtenContents, string(data))
		return nil
	}
	cmd.fs.MkdirAll = func(path string, perm os.FileMode) error {
		return nil
	}

	err := cmd.Run([]string{"-p", "github.com/moneyforward/ddtrace/internal/cli"}, nil)
	require.NoError(t, err)

	require.Len(t, writtenContents, 1)
	assert.Contains(t, writtenContents[0], "go:generate")
	assert.Contains(t, writtenContents[0], "ddtrace gen -p")
}

func TestGenerateCommand_Run_InvalidPackage(t *testing.T) {
	cmd := NewGenerateCommand()

	err := cmd.Run([]string{"-p", "nonexistent/package/path"}, nil)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "failed to load source package")
}

func TestHelper_UpFirst(t *testing.T) {
	tests := []struct {
		name string
		in   string
		out  string
	}{
		{name: "first is lower-cased", in: "typeName", out: "TypeName"},
		{name: "single letter", in: "v", out: "V"},
		{name: "multi-bytes chars", in: "йоу", out: "Йоу"},
		{name: "empty string", in: "", out: ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.out, upFirst(tt.in))
		})
	}
}

func TestHelper_DownFirst(t *testing.T) {
	tests := []struct {
		name string
		in   string
		out  string
	}{
		{name: "first is upper-cased", in: "TypeName", out: "typeName"},
		{name: "single letter", in: "V", out: "v"},
		{name: "multi-bytes chars", in: "Йоу", out: "йоу"},
		{name: "empty string", in: "", out: ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.out, downFirst(tt.in))
		})
	}
}

func Test_toSnakeCase(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"", ""},
		{"already_snake", "already_snake"},
		{"A", "a"},
		{"AA", "aa"},
		{"AaAa", "aa_aa"},
		{"HTTPRequest", "http_request"},
		{"BatteryLifeValue", "battery_life_value"},
		{"Id0Value", "id0_value"},
		{"ID0Value", "id0_value"},
	}

	for _, test := range tests {
		assert.Equal(t, test.want, toSnakeCase(test.input))
	}
}

func TestExtractAfterPackage(t *testing.T) {
	input := `// Code generated by ddtrace. DO NOT EDIT.
package trace

import (
	"context"
)

type FooWithTracing struct {}
`
	result := extractAfterPackage(input)
	assert.NotContains(t, result, "package trace")
	assert.Contains(t, result, "import")
	assert.Contains(t, result, "FooWithTracing")
}

func TestExtractBodyOnly(t *testing.T) {
	input := `// Code generated by ddtrace. DO NOT EDIT.
package trace

import (
	"context"
	"gopkg.in/DataDog/dd-trace-go.v1/ddtrace"
)

// FooWithTracing implements Foo
type FooWithTracing struct {}

func NewFooWithTracing() {}
`
	result := extractBodyOnly(input)
	assert.NotContains(t, result, "package")
	assert.NotContains(t, result, "import")
	assert.Contains(t, result, "FooWithTracing struct")
	assert.Contains(t, result, "NewFooWithTracing")
}
